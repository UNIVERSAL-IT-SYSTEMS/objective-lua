require 'olua'
require 'olua.lib'
require 'markdown'
local table_concat = table.concat 

local VERSION = "0.1"

local OLDOT

--- Stores all the documentation about an OLua method.

@implementation OldotMethod : olua.lib.Object
	@statics
		local name = ""
		local selector = ""
		local arguments = {}
		local documentation = ""
		local argumentDocumentation = nil
		local returnDocumentation = nil
	@end
	
	- setName: s
	do
		name = s
	end
	
	- name
	do
		return name
	end
	
	- setSelector: s
	do
		selector = s
	end
	
	- selector
	do
		return selector
	end
	
	- setArguments: a
	do
		arguments = a
	end
	
	- arguments
	do
		return arguments
	end
	
	- setArgumentDocumentation: d
	do
		argumentDocumentation = d
	end
	
	- setReturnDocumentation: d
	do
		returnDocumentation = d
	end
	
	- setDocumentation: s
	do
		documentation = s
	end
	
	- documentation
	do
		return documentation
	end
	
	- emitTo: stream
	do
		stream[#stream+1] = "### <a name='"..name.."'>"..name.."</a>"			
		stream[#stream+1] = documentation
		
		local s = {}
		if (#arguments == 0) then
			s[#s+1] = "<code>"..selector[1].."</code>"
		else
			for i = 1, #arguments do
				local se = selector[i]
				local ae = arguments[i]
				
				s[#s+1] = "<code>"
				if se then
					s[#s+1] = se
				end
				if not se or (se:sub(-1) ~= ":") then
					s[#s+1] = ","
				end
				s[#s+1] = " </code>"
				
				s[#s+1] = "<i>"
				s[#s+1] = ae
				s[#s+1] = "</i>"
			end
		end
		
		stream[#stream+1] = "#### "..table_concat(s)
		
		if argumentDocumentation then
			stream[#stream+1] = "#### Parameters:"
			
			stream[#stream+1] = "<dl>"
			for _, a in ipairs(argumentDocumentation) do
				stream[#stream+1] = "<dt><i>"
				stream[#stream+1] = a[1]
				stream[#stream+1] = "</i></dt>"
				
				stream[#stream+1] = "<dd>"
				stream[#stream+1] = a[2]
				stream[#stream+1] = "</dd>"
			end
			stream[#stream+1] = "</dl>"
		end
				 
		if returnDocumentation then
			stream[#stream+1] = "#### Returning:"
			stream[#stream+1] = returnDocumentation
		end
				 
	end
@end

--- Stores all the documentation about a OLua category.

@implementation OldotCategory : olua.lib.Object
	@statics	
		local name = ""
		local documentation = ""
		local methods = {}
	@end
	
	- setName: s do
		name = s
	end
	
	- name do
		return name
	end
	
	- setDocumentation: s do
		documentation = s
	end
	
	- documentation do
		return documentation
	end
	
	- findMethod: name do
		local method = methods[name]
		if not method then
			method = [[OldotMethod alloc] init]
			methods[name] = method
			[method setName: name]
		end
		return method
	end

	- methods
	do
		local c = {}
		for methodname, _ in pairs(methods) do
			c[#c+1] = methodname
		end
		table.sort(c)
		return c
	end
	
	- emitTo: stream
	do
		stream[#stream+1] = "<a name='"..name.."'>".."</a>"			
		stream[#stream+1] = documentation
		
		for _, methodname in ipairs([self methods]) do
			local method = [self findMethod: methodname]
			[method emitTo: stream]
		end
	end
@end

--- Stores all the documentation about a OLua class.

@implementation OldotClass : olua.lib.Object
	@statics
		local library = ""
		local name = ""
		local superclass = nil
		local categories = {}
	@end
	
	- setLibrary: s do
		library = s
	end
	
	- library do
		return library
	end
	
	- setName: s do
		name = s
	end
	
	- name do
		return name
	end
	
	- setSuperclass: s do
		superclass = s
	end
	
	- superclass
	do
		return superclass
	end
	
	- findCategory: c do
		local category = categories[c]
		if not category then
			category = [[OldotCategory alloc] init]
			categories[c] = category
			[category setName: c]
		end
		return category
	end
	
	- categories
	do
		local c = {}
		for categoryname, _ in pairs(categories) do
			c[#c+1] = categoryname
		end
		table.sort(c)
		return c
	end

	- emitTo: stream
	do
		local _, _, library, name = [self name]:find("^([%w%.]+)%.(%w*)$")
		stream[#stream+1] = "<h2>"
		if library then
			stream[#stream+1] = "<font size='-1'>"
			stream[#stream+1] = library
			stream[#stream+1] = "</font></br>Class "
			stream[#stream+1] = name
		else
			name = [self name]
			stream[#stream+1] = "Class "
			stream[#stream+1] = name
		end
		stream[#stream+1] = "</h2>"
		
		do
			local hierarchy = {}
			local c = self
			repeat
				hierarchy[#hierarchy+1] = c
				local scname = [c superclass]
				if not scname then
					break
				end
				c = [OLDOT findClass: scname]
			until not c
			
			local indent = 0
			local s = {"<pre>"}
			
			for i = #hierarchy, 1, -1 do
				local c = hierarchy[i]
				local cname = [c name]
				
				if (i ~= #hierarchy) then
					for j = 0, indent-1 do
						s[#s+1] = "&nbsp;"
					end
					s[#s+1] = "└─ "
					indent = indent + 3
				end
				if (c ~= self) then
					s[#s+1] = "<a href='"
					s[#s+1] = cname
					s[#s+1] = ".html'>"
					s[#s+1] = cname
					s[#s+1] = "</a>"
				else
					s[#s+1] = "<b>"
					s[#s+1] = cname
					s[#s+1] = "</b>"
				end
				s[#s+1] = "</br>"
			end
			s[#s+1] = "</pre>"
			stream[#stream+1] = table_concat(s)
		end
		
		stream[#stream+1] = "<hr/>"
		
		local defaultCategory = [self findCategory: "-default-"]
		if defaultCategory then
			stream[#stream+1] = markdown([defaultCategory documentation])
		end
		
		stream[#stream+1] = "<hr/>"
		
		local allmethods = {}
		for _, categoryname in ipairs([self categories]) do
			local category = [self findCategory: categoryname]
			for _, methodname in ipairs([category methods]) do
				allmethods[#allmethods+1] = {
					name=methodname,
					method=[category findMethod: methodname]
				}
			end 
		end
		table.sort(allmethods,
			function(m1, m2)
				return m1.name < m2.name
			end)

		stream[#stream+1] = "<dl class='methodlist'>"
		for _, m in ipairs(allmethods) do
			stream[#stream+1] = "<dt><a href='#"
			stream[#stream+1] = m.name
			stream[#stream+1] = "'>"
			stream[#stream+1] = m.name
			stream[#stream+1] = "</a></dt>"
			
			local doc = [m.method documentation]
			if doc then
				local i = doc:find("\n\n")
				doc = doc:sub(1, i)
			end
			if doc then
				stream[#stream+1] = "<dd>"
				stream[#stream+1] = markdown(doc)
				stream[#stream+1] = "</dd>"
			end
		end
		stream[#stream+1] = "</dl>"		
	end
@end


--- Main application class.

@implementation Oldot : olua.lib.Application
	- init
	do
		[super init]
		[self initUi]
		return self
	end
	
	- name
	do
		return "oldot"
	end
	
	- run
	do
		[self checkArguments]
		
		local files = [self remainingArguments]
		if (#files == 0) then
			[self error: "you must specify at least one input file"]
		end
		
		local stderr = io.stderr
		stderr:write("Reading: ")
		stderr:flush()
		for _, filename in ipairs(files) do
			[self parse: filename]
			stderr:write(".")
			stderr:flush()
		end
		
		local fp = io.stdout
		stderr:write("\nWriting: ")
		stderr:flush()
		for _, classname in ipairs([self classes]) do
			local class = [self findClass: classname]

			local stream = {
				"<html><head>",
				"<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>",
				"<title>", classname, "</title></head><body>"
			}
			[class emitTo: stream]
			stream[#stream+1] = "</body></html>"
			
			local filename = classname..".html"
			fp = [self openOutputFile: filename]
			fp:write(table_concat(stream))
			fp:close()
			
			stderr:write(".")
			stderr:flush()
		end
		stderr:write("\n")
	end
@end

@implementation Oldot (UserInterface)
	@statics
		local outputdir
	@end
	
	- initUi
	do
		[self addOptions: {"h", "help"}
			withHandler:
				function(arg)
					[self showHelp]
					os.exit(0)
				end]
				
		[self addOptions: {"o", "output"}
			withHandler:
				function(arg)
					outputdir = arg
					return 1
				end]
	end

	- showHelp
	do
		local stderr = io.stderr
		stderr:write("oldot ", VERSION, "\n")
		stderr:write("Objective Lua documentation tool\n")
		stderr:write("© 2009 David Given\n")
		stderr:write("\n")
		stderr:write("Syntax: oldot [<options>...] <inputfile.olua>...\n")
		stderr:write("   --help       -h     display this message\n")
		stderr:write("   --output X   -oX    specify output directory\n")
	end
	
	- checkArguments
	do
		if not outputdir then
			[self error: "You must specify an output directory."]
		end
	end
		
	- openOutputFile: filename
	do
		local f = outputdir.."/"..filename
		local fp, e = io.open(f, "w")
		if not fp then
			[self error: "Unable to open output file %q: %s", filename, e]
		end
		return fp
	end
@end

@implementation Oldot (DataStorage)
	@statics
		local classes = {}
	@end
	
	- findClass: classname do
		local class = classes[classname]
		if not class then
			class = [[OldotClass alloc] init]
			classes[classname] = class
			[class setName: classname]
		end
		return class
	end
	
	- classes do
		local c = {}
		for classname, _ in pairs(classes) do
			c[#c+1] = classname
		end
		table.sort(c)
		return c
	end
@end
	
@implementation Oldot (FileParsing) 
	@statics
		local currentChunk
		local docChunk
		local argChunk
		local retChunk
		local library
		local category
		
		local function reset()
			docChunk = {}
			currentChunk = docChunk
			argChunk = nil
			retChunk = nil
		end
		
		local function documentationline(line)
			local s, e, arg, rest = line:find("^@param%s+(%w+)%s+(.*)$")
			if s then
				if not argChunk then
					argChunk = {}
				end
				
				currentChunk = {}
				argChunk[#argChunk+1] = {arg, currentChunk}
				line = rest
			end
			
			s, e, rest = line:find("^@return%s+(.*)$")
			if s then
				retChunk = {}
				currentChunk = retChunk
				line = rest
			end
			
			currentChunk[#currentChunk + 1] = line
		end
		
		local function moduleLine(m)
			library = m
		end
		
		local function applymodule(s)
			if s:find("%.") then
				return s
			end
			if library then
				return library .. "." .. s
			end
			return s
		end
		
		local function implementationWithSuperclassLine(subclass, superclass)
			local doc = table_concat(docChunk, "\n")
			reset()
			
			subclass = applymodule(subclass)
			superclass = applymodule(superclass)
			
			local class = [self findClass: subclass]
			[class setSuperclass: superclass]
			category = [class findCategory: "-default-"]
			[category setDocumentation: doc]
		end
		
		local function implementationWithCategoryLine(subclass, categoryname)
			local doc = table_concat(docChunk, "\n")
			reset()
			
			subclass = applymodule(subclass)
			
			local class = [self findClass: subclass]
			category = [class findCategory: categoryname]
			[category setDocumentation: doc]
		end
		
		local function methodDefinitionLine(line)
			local doc = table_concat(docChunk, "\n")
			local ret = nil
			if retChunk then
			 	ret = table_concat(retChunk, "\n")
			end
			
			local arg = nil
			if argChunk then
				arg = {}
				for _, a in ipairs(argChunk) do
					arg[#arg+1] = {a[1], table_concat(a[2], "\n")}
				end
			end
			reset()
			
			local classmethod = false
			if line:find("^%+") then
				classmethod = true
			end
			
			local i = 2
			local function gettoken()
				local s, e, c
				-- skip whitespace
				
				s, e = line:find("^%s+", i)
				if s then
					i = e + 1
				end
				
				if (i > #line) then
					return nil
				end
				 
				s, e, c = line:find("^(%w+:?)", i)
				if s then
					i = e + 1
					return c
				end
				
				s, e, c = line:find("^,", i)
				if s then
					i = e + 1
					return ","
				end
				
				s, e, c = line:find("^%.%.%.", i)
				if s then
					i = e + 1
					return "..."
				end
				
				return nil
			end

			local selector = {}
			local args = {}
			
			local t = gettoken()
			if not t:find(":$") then
				selector[#selector+1] = t
				t = gettoken()
			else
				repeat
					selector[#selector+1] = t
					args[#args+1] = gettoken()
					t = gettoken()
				until not t or (t == ",") or (t == "do")
			end

			while (t == ",") do
				args[#args+1] = gettoken()
				t = gettoken()
			end
		
			local name = table_concat(selector)
			
			local method
			if classmethod then
				name = "+"..name
			else
				name = "-"..name
			end
			local method = [category findMethod: name]
			[method setSelector: selector]
			[method setArguments: args]
			[method setArgumentDocumentation: arg]
			[method setReturnDocumentation: ret]
			[method setDocumentation: doc]
		end
		
		local function processline(line)
			-- Strip spaces.
			
			line = line:gsub("^%s*", "")
			line = line:gsub("%s*$", "")

			-- Documentation chunk?
			
			local e, _, m = line:find(
				"^%-%-%-%s(.*)$")
			if e then
				documentationline(m)
				return
			end
			
			-- Empty line in a documentation chunk?

			local e, _, m = line:find(
				"^%-%-%-$")
			if e then
				documentationline("")
				return
			end
						
			-- module("...", ...?

			local e, _, m = line:find(
				"^module%([\"']([%w.]+)[\"']")
			if e then
				moduleLine(m)
			end
			
			-- @interface Subclass : Superclass?
			
			local e, _, subclass, superclass = line:find(
				"^@implementation%s+([%w.]+)%s*:%s*([%w.]+)$")
			if e then
				implementationWithSuperclassLine(subclass, superclass)
			end
			
			-- @interface Subclass (Category)?
			
			local e, _, subclass, category = line:find(
				"^@implementation%s+([%w.]+)%s*%(([%w.]+)%)$")
			if e then
				implementationWithCategoryLine(subclass, category)
			end
			
			-- [+-] selector...?
			
			local e, _ = line:find(
				"^[-+]%s+")
			if e then
				methodDefinitionLine(line)
			end
		end
	@end
	
	- parse: filename do
		local fp = io.open(filename)
		if not fp then
			[self error: "unable to open input file %q", filename]
		end
		
		reset()
		library = nil
		
		for line in fp:lines() do
			processline(line)
		end
		
		if (#docChunk > 0) then
			[self error: "orphaned documentation block at end of file"]
		end
		
		fp:close()
	end
@end

OLDOT = [[Oldot alloc] init]
return [OLDOT runWithArgs: {...}]
